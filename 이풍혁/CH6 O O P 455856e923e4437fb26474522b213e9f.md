# CH6 O.O.P

- 객체 지향 프로그래밍(Object Oriented Programming)의 개념
    - 객체
        - 상태와 동작
    - 클래스
        - 하나의 클래스는 하나의 작업만 한다.
        - 인스턴스화하기 전까지는 메모리의 힙 영영을 소모하지 않는다.
        
        <aside>
        💡 한 클래스를 기반으로 객체를 만드는 과정을 인스턴스화한다
        
        </aside>
        
        - 클래스의 정의는 파일 형태로 하드 드라이브에 저장될 뿐 메모리의 힙 영역을 소모하지 않는다.
        - 인스턴스화, 객체로 만들면 객체는 메모리 힙 영역에 할당된다.
    - 추상화
        - 사용자와 관련있는 내용만 노출하고 나머지 세부 내용은 숨기는 개념
        - 무슨 기능을 하는지만 알려주고, 내부 구현내용은 숨겨놓는다.
    - 캡슐화
        - 정보은닉의 매커니즘
        
         그렇다면 추상화랑 캡슐화의 차이는 무엇인가 
        
        - 느슨한 결합( 인터페이스의 사용 ), 재사용성 등에 활용가능
        - 접근제어자 ( public, private, protected ) 로 캡슐화를 하게 된다.
    - 상속
        - 코드의 재사용
        - IS-A 관계, 부모-자녀관계
            - 
            
            ```java
            B extends A 
            ```
            
        - java에서 `extends` 키워드로 구현 가능
        - 여러 클래스를 상속할 수 없다.
    - 다형성 ( polymorphism )
        - 다형성을 구현하는 방법이 `overloading`과 `overriding` 이다 (?)
            - overloading 이 컴파일 타임 다형성 (?)
            - overriding이 런타임 다형성 (?)
            
            **오버로딩, 오버라이딩 코드정리**
            
    - 연관
        - 일대일, 일대다, 다대일, 다대다 등의 관계
        
        다형성이랑 관련이 있는 듯
        
    - 집약
        - HAS-A 관계
        - 집약과 연관은 밀접한 관련이 있으므로, 서로 관련지어서 설명할 수 있어야하고 차이점에 대해 설명할 수 있어야 한다.
        - 한 객체가 다른 객체를 가지고 있다.
    - 구성
        - 단독으로 존재할 수 없는 객체를 포함하는 HAS-A 관계
        - 집약은 두 객체가 자체의 수명주기 (Life cycle)를 가지고 있는 경우지만, 구성은 한 객체가 다른 객체에게 종속된다. ( 한 객체가 파괴될 때 같이 파괴된다. )
        - 객체의 가시성을 제어하고 코드를 재사용하므로 상속보다 더 낫다
- SOLID 원칙
    - S: 단일 책임 원칙 : Solid responsibility principle
        - 하나의 객체가 하나의 책임만 가진다.
        - 높은 유지보수성과 가시성
        - 예제 코드 : 넓이 관련이면 넓이 관련된 역할만 수행해야한다.
    - O: 개방-폐쇄 원칙 open-closed principle
        - **확장**에 대해선 **개방적**
            - 다른 개발자가 클래스를 확장하기만 해도 클래스의 동작을 수정할 수 있도
        - **수정**에 있어서 **폐쇄적**
    - L:리스코프 치환원칙, Liskov substitution principle
        - 파생 타입은 반드시 기본 타입을 완벽하게 대체할 수 있어야 한다.
        - 다형성 관련 개념으로 보임
        - 
    - I : 인터페이스 분리원칙, Interface segregation principle
        - 클라이언트가 사용하지 않을 **불필요한 메서드를 강제로 구현하게 해서는 안 된다.**
        - 즉 인터페이스를 구현하는 개발자에게 불필요한 메소드 구현을 강제하지 않도록 필요한 추상 메소드들만을 담고 있는 인터페이스로 분리해야한다.
    - D:의존관계 역전 원칙, dependency inversion principle
        - 구체화가 아닌 추상화에 의존해야 한다.
- Overriding 과 Overloading ( 객체지향 관점에서 )
    - Overriding
        - 같은 이름 다른 동작을 하는 2개의 ( 정확히는 2개 이상이 아닌가? ) 메소드를 작성하는 것
        - 전제조건 : static, private, final 가 붙으면 안된다.
        - 같은 클래스에 있는 메소드는 Override 할 수 없다.
    - Overloading
        - 메소드의 **시그니처**를 달리하면서 같은 이름의 메소드를 여러번 구현할 수 있다.
            - 여기서 시그니처란. 인수의 **개수, 타입, 순서**를 말한다.
            - **return type**은 시그니처가 아니다.
        - private, static, fianl method를 overload 할 수 있다.
        
        그렇다면 override와 다르게 왜 overloading은 private, static, final에 제한이 없을까 
        
        - overring은 시그니처로 구분할 만한 무언가 없어.
        - 근데 overloading은 시그니처를 달리하면서 구현을 하기 때문에, private, stataic, final이 붙어도 문제가 없는거지
        - 
- GOF의 디자인 패턴 ( 질문만, 이 부분은 심화로 들어가는 듯, 깊게 공부하고 싶다면 디자인 패턴에 대한 별도의 책을 읽는 것이 좋다. )
    
    책에서 다루지 않았다. 몇가지 질문에 대한 답변만 적어놓음.
    
    - 싱글턴 패턴 ( Singleton pattern )
        - 클래스의 애플리케이션 레벨(전역) 인스턴스가 하나만 필요할 때
        - SPRING MVC 에서 Bean Scope 에서 관련 개념으로 등장한다.
            - 하나의 클래스 파일을 기준으로 Ioc 컨테이너에 Bean을 올리게 되는데, 하나의 클래스에 대해선 하나의 Bean만 존재한다. **Single**
            
            ```xml
            <bean id="petOwner" class="com.spring.PetOwner" scope="singleton">
                <constructor-arg name="animal" ref="dog"></constructor-arg>
            </bean>
            ```
            
        - 이펙티브 자바에서는 자바 열거형( enum ) 을 사용하는 것이 싱글톤 패턴을 구현하는 가장 좋은 방법이다.
    - 프록시 패턴 ( Proxy Pattern )
        - 무언가에 대한 접근 제어 게이트웨이를 제공하는 데 유용
        - 실제 객체를 대신할 대리 객첼르 생성한다.
        - 실제 객체에 대한 각 요청은 대리 객체를 통과한다.
            - 대리 객체는 이를 실제 객체로 전달할 방법과 시점을 결정한다.
        - 인터넷의 프록시 서버가 대표적
- 코딩테스트